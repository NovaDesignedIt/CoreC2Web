import {
  require_jsx_runtime
} from "./chunk-3JXUIMPU.js";
import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/@devbookhq/splitter/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/@devbookhq/splitter/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/@devbookhq/splitter/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/@devbookhq/splitter/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@devbookhq/splitter/lib/mjs/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
function c(e2, t2) {
  const n2 = getComputedStyle(t2);
  if (!n2)
    return;
  let i2 = e2 === z.Horizontal ? t2.clientWidth : t2.clientHeight;
  return 0 !== i2 ? (e2 === z.Horizontal ? i2 -= parseFloat(n2.paddingLeft) + parseFloat(n2.paddingRight) : i2 -= parseFloat(n2.paddingTop) + parseFloat(n2.paddingBottom), i2) : void 0;
}
function l(e2, t2, n2 = [], r2 = { condition: true }) {
  const { condition: a2 } = r2, o2 = function(e3, t3) {
    var n3 = {};
    for (var i2 in e3)
      Object.prototype.hasOwnProperty.call(e3, i2) && t3.indexOf(i2) < 0 && (n3[i2] = e3[i2]);
    if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
      var r3 = 0;
      for (i2 = Object.getOwnPropertySymbols(e3); r3 < i2.length; r3++)
        t3.indexOf(i2[r3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, i2[r3]) && (n3[i2[r3]] = e3[i2[r3]]);
    }
    return n3;
  }(r2, ["condition"]);
  (0, import_react.useEffect)(() => (a2 && window.addEventListener(e2, t2, o2), () => {
    a2 && window.removeEventListener(e2, t2);
  }), [e2, t2, a2, ...n2]);
}
!function(e2, t2) {
  void 0 === t2 && (t2 = {});
  var n2 = t2.insertAt;
  if (e2 && "undefined" != typeof document) {
    var i2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
    r2.type = "text/css", "top" === n2 && i2.firstChild ? i2.insertBefore(r2, i2.firstChild) : i2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = e2 : r2.appendChild(document.createTextNode(e2));
  }
}("/* === Main Container === */\n.__dbk__container {\n  height: 100%;\n  width: 100%;\n\n  display: flex;\n  overflow: hidden;\n}\n\n.__dbk__container.Horizontal {\n  flex-direction: row;\n}\n\n.__dbk__container.Vertical {\n  flex-direction: column;\n}\n/* ====== */\n\n/* === Wrapper for each child element === */\n.__dbk__child-wrapper {\n  height: 100%;\n  width: 100%;\n}\n/* ====== */\n\n/* === Gutter === */\n.__dbk__gutter {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n/* .__dbk__gutter > div {\n  background: red;\n} */\n.__dbk__gutter.Horizontal {\n  height: 100%;\n  padding: 0 2px;\n  flex-direction: column;\n}\n.__dbk__gutter.Horizontal:hover {\n  cursor: col-resize;\n}\n\n.__dbk__gutter.Vertical {\n  width: 100%;\n  padding: 2px 0;\n  flex-direction: row;\n}\n.__dbk__gutter.Vertical:hover {\n  cursor: row-resize;\n}\n\n.__dbk__gutter.Light {\n  background: #EDF0EF;\n}\n.__dbk__gutter.Light:hover > .__dbk__dragger {\n  background: #76747B;\n}\n\n.__dbk__gutter.Dark {\n  background: #020203;\n}\n.__dbk__gutter.Dark:hover > .__dbk__dragger {\n  background: #9995A3;\n}\n/* ====== */\n\n/* === Gutter's Dragger === */\n.__dbk__dragger {\n  border-radius: 2px;\n}\n\n.__dbk__dragger.Horizontal {\n  width: 4px;\n  height: 24px;  \n}\n\n.__dbk__dragger.Vertical {\n  width: 24px;\n  height: 4px;  \n}\n\n.__dbk__dragger.Light {\n  background: #A6ACB5;\n}\n\n.__dbk__dragger.Dark {\n  background: #434252;\n}\n/* ====== */");
var u = import_react.default.forwardRef(({ className: t2, theme: n2, draggerClassName: i2, direction: r2 = z.Vertical, onDragging: a2 }, o2) => {
  const g2 = `__dbk__gutter ${r2} ${t2 || n2}`, d2 = `__dbk__dragger ${r2} ${i2 || n2}`;
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ className: g2, ref: o2, dir: r2, onMouseDown: a2, onTouchStart: C ? a2 : void 0 }, { children: (0, import_jsx_runtime.jsx)("div", { className: d2 }, void 0) }), void 0);
});
var h;
function p(e2, t2, n2) {
  let i2, r2;
  return t2 ? (i2 = e2 / 2, r2 = e2) : n2 ? (i2 = e2, r2 = e2 / 2) : (i2 = e2, r2 = e2), { aGutterSize: i2, bGutterSize: r2 };
}
function f(e2, t2) {
  switch (t2.type) {
    case h.SetIsReadyToCompute:
      return Object.assign(Object.assign({}, e2), { isReady: t2.payload.isReady });
    case h.CreatePairs: {
      const { direction: n2, children: i2, gutters: r2 } = t2.payload, a2 = i2[0].parentNode;
      if (!a2)
        throw new Error("Cannot create pairs - parent is undefined.");
      const o2 = c(n2, a2);
      if (void 0 === o2)
        throw new Error(`Cannot create pairs - parent has undefined or zero size: ${o2}.`);
      const g2 = [];
      return i2.forEach((e3, t3) => {
        if (t3 > 0) {
          const e4 = i2[t3 - 1], o3 = i2[t3], d2 = r2[t3 - 1], s2 = n2 === z.Horizontal ? e4.getBoundingClientRect().left : e4.getBoundingClientRect().top, c2 = n2 === z.Horizontal ? o3.getBoundingClientRect().right : o3.getBoundingClientRect().bottom, l2 = n2 === z.Horizontal ? e4.getBoundingClientRect().width + d2.getBoundingClientRect().width + o3.getBoundingClientRect().width : e4.getBoundingClientRect().height + d2.getBoundingClientRect().height + o3.getBoundingClientRect().height, u2 = n2 === z.Horizontal ? d2.getBoundingClientRect().width : d2.getBoundingClientRect().height, h2 = { idx: t3 - 1, a: e4, b: o3, gutter: d2, parent: a2, start: s2, end: c2, size: l2, gutterSize: u2, aSizePct: 100 / i2.length, bSizePct: 100 / i2.length };
          g2.push(h2);
        }
      }), Object.assign(Object.assign({}, e2), { pairs: g2 });
    }
    case h.StartDragging: {
      const { gutterIdx: n2 } = t2.payload;
      return Object.assign(Object.assign({}, e2), { isDragging: true, draggingIdx: n2 });
    }
    case h.StopDragging:
      return Object.assign(Object.assign({}, e2), { isDragging: false });
    case h.CalculateSizes: {
      const { direction: n2, gutterIdx: i2 } = t2.payload, r2 = e2.pairs[i2], a2 = c(n2, r2.parent);
      if (!a2)
        throw new Error("Cannot calculate sizes - 'pair.parent' has undefined or zero size.");
      const o2 = r2.gutter[n2 === z.Horizontal ? "clientWidth" : "clientHeight"], g2 = 0 === i2, d2 = i2 === e2.pairs.length - 1, { aGutterSize: s2, bGutterSize: l2 } = p(o2, g2, d2);
      let u2, h2, f2, _2, b2;
      return n2 === z.Horizontal ? (u2 = r2.a.getBoundingClientRect().left, h2 = r2.b.getBoundingClientRect().right, _2 = (r2.a.getBoundingClientRect().width + s2) / a2 * 100, b2 = (r2.b.getBoundingClientRect().width + l2) / a2 * 100, f2 = r2.a.getBoundingClientRect().width + s2 + l2 + r2.b.getBoundingClientRect().width) : (u2 = r2.a.getBoundingClientRect().top, h2 = r2.b.getBoundingClientRect().bottom, _2 = (r2.a.getBoundingClientRect().height + s2) / a2 * 100, b2 = (r2.b.getBoundingClientRect().height + l2) / a2 * 100, f2 = r2.a.getBoundingClientRect().height + s2 + l2 + r2.b.getBoundingClientRect().height), e2.pairs[i2] = Object.assign(Object.assign({}, r2), { start: u2, end: h2, size: f2, aSizePct: _2, bSizePct: b2, gutterSize: o2 }), Object.assign({}, e2);
    }
    default:
      return e2;
  }
}
function _(e2, t2 = 0, n2 = []) {
  return import_react.Children.toArray(e2).reduce((e3, i2, r2) => ((0, import_react_is.isFragment)(i2) ? e3.push.apply(e3, _(i2.props.children, t2 + 1, n2.concat(i2.key || r2))) : (0, import_react.isValidElement)(i2) ? e3.push((0, import_react.cloneElement)(i2, { key: n2.concat(String(i2.key)).join(".") })) : "string" != typeof i2 && "number" != typeof i2 || e3.push(i2), e3), []);
}
!function(e2) {
  e2[e2.SetIsReadyToCompute = 0] = "SetIsReadyToCompute", e2[e2.CreatePairs = 1] = "CreatePairs", e2[e2.CalculateSizes = 2] = "CalculateSizes", e2[e2.StartDragging = 3] = "StartDragging", e2[e2.StopDragging = 4] = "StopDragging";
}(h || (h = {}));
var b = (e2) => "changedTouches" in e2;
var z;
var w;
!function(e2) {
  e2.Horizontal = "Horizontal", e2.Vertical = "Vertical";
}(z || (z = {})), function(e2) {
  e2.Light = "Light", e2.Dark = "Dark";
}(w || (w = {}));
var C = "undefined" != typeof window && "ontouchstart" in window;
function y(e2) {
  return e2 === z.Horizontal ? "col-resize" : "row-resize";
}
var S = { isReady: false, isDragging: false, pairs: [] };
function m({ direction: r2 = z.Horizontal, minWidths: a2 = [], minHeights: o2 = [], initialSizes: s2, gutterTheme: m2 = w.Dark, gutterClassName: x, draggerClassName: k, children: v, onResizeStarted: R, onResizeFinished: B, classes: D = [] }) {
  const I = _(v), [E, H] = (0, import_react.useReducer)(f, S), j = (0, import_react.useRef)(null), O = (0, import_react.useRef)([]), N = (0, import_react.useRef)([]);
  O.current = [], N.current = [];
  const P = import_react.default.useCallback((e2) => {
    H({ type: h.SetIsReadyToCompute, payload: { isReady: e2 } });
  }, []), $ = import_react.default.useCallback((e2, t2) => {
    H({ type: h.StartDragging, payload: { gutterIdx: t2 } });
    const n2 = E.pairs[t2];
    null == R || R(n2.idx), n2.a.style.userSelect = "none", n2.b.style.userSelect = "none", n2.gutter.style.cursor = y(e2), n2.parent.style.cursor = y(e2), document.body.style.cursor = y(e2);
  }, [E.pairs]), T = import_react.default.useCallback(() => {
    H({ type: h.StopDragging });
    const e2 = [];
    for (let t3 = 0; t3 < E.pairs.length; t3++) {
      const n2 = E.pairs[t3], i2 = c(r2, n2.parent);
      if (void 0 === i2)
        throw new Error("Cannot call the 'onResizeFinished' callback - parentSize is undefined");
      if (void 0 === n2.gutterSize)
        throw new Error("Cannot call 'onResizeFinished' callback - gutterSize is undefined");
      const a3 = 0 === t3, o3 = t3 === E.pairs.length - 1, g2 = n2.a.getBoundingClientRect()[r2 === z.Horizontal ? "width" : "height"], { aGutterSize: d2, bGutterSize: s3 } = p(n2.gutterSize, a3, o3), l2 = (g2 + d2) / i2 * 100;
      if (e2.push(l2), o3) {
        const t4 = (n2.b.getBoundingClientRect()[r2 === z.Horizontal ? "width" : "height"] + s3) / i2 * 100;
        e2.push(t4);
      }
    }
    if (void 0 === E.draggingIdx)
      throw new Error("Could not reset cursor and user-select because 'state.draggingIdx' is undefined");
    const t2 = E.pairs[E.draggingIdx];
    null == B || B(t2.idx, e2), t2.a.style.userSelect = "", t2.b.style.userSelect = "", t2.gutter.style.cursor = "", t2.parent.style.cursor = "", document.body.style.cursor = "";
  }, [E.draggingIdx, E.pairs, r2]), F = import_react.default.useCallback((e2, t2) => {
    H({ type: h.CalculateSizes, payload: { direction: e2, gutterIdx: t2 } });
  }, []), G = import_react.default.useCallback((e2, t2, n2) => {
    H({ type: h.CreatePairs, payload: { direction: e2, children: t2, gutters: n2 } });
  }, []), L = import_react.default.useCallback((e2, t2, n2, i2) => {
    const r3 = t2[0].parentNode;
    if (!r3)
      throw new Error("Cannot set initial sizes - parent is undefined");
    if (void 0 === c(e2, r3))
      throw new Error("Cannot set initial sizes - parent has undefined size");
    t2.forEach((r4, a3) => {
      const o3 = 0 === a3, g2 = a3 === t2.length - 1;
      let d2, s3 = 0;
      if (t2.length > 1) {
        s3 = n2[g2 ? a3 - 1 : a3].getBoundingClientRect()[e2 === z.Horizontal ? "width" : "height"], s3 = o3 || g2 ? s3 / 2 : s3;
      }
      d2 = i2 && a3 < i2.length ? `calc(${i2[a3]}% - ${s3}px)` : `calc(${100 / t2.length}% - ${s3}px)`, e2 === z.Horizontal ? (r4.style.width = d2, r4.style.height = "100%") : (r4.style.height = d2, r4.style.width = "100%");
    });
  }, []), V = import_react.default.useCallback((e2, t2) => {
    if (void 0 === E.draggingIdx)
      throw new Error("Cannot adjust size - 'draggingIdx' is undefined");
    const n2 = E.pairs[E.draggingIdx];
    if (void 0 === n2.size)
      throw new Error("Cannot adjust size - 'pair.size' is undefined");
    if (void 0 === n2.gutterSize)
      throw new Error("Cannot adjust size - 'pair.gutterSize' is undefined");
    const i2 = n2.aSizePct + n2.bSizePct, r3 = t2 / n2.size * i2, a3 = i2 - t2 / n2.size * i2, o3 = 0 === E.draggingIdx, g2 = E.draggingIdx === E.pairs.length - 1, { aGutterSize: d2, bGutterSize: s3 } = p(n2.gutterSize, o3, g2), c2 = `calc(${r3}% - ${d2}px)`, l2 = `calc(${a3}% - ${s3}px)`;
    e2 === z.Horizontal ? (n2.a.style.width = c2, n2.b.style.width = l2) : (n2.a.style.height = c2, n2.b.style.height = l2);
  }, [E.draggingIdx, E.pairs, r2]), A = import_react.default.useCallback((e2, t2, n2) => {
    if (!E.isDragging)
      return;
    if (void 0 === E.draggingIdx)
      throw new Error("Cannot drag - 'draggingIdx' is undefined");
    const i2 = E.pairs[E.draggingIdx];
    if (void 0 === i2.start)
      throw new Error("Cannot drag - 'pair.start' is undefined");
    if (void 0 === i2.size)
      throw new Error("Cannot drag - 'pair.size' is undefined");
    if (void 0 === i2.gutterSize)
      throw new Error("Cannot drag - 'pair.gutterSize' is undefined");
    let r3 = function(e3, t3) {
      const n3 = b(t3) ? t3.changedTouches[0] : t3;
      return e3 === z.Horizontal ? n3.clientX : n3.clientY;
    }(t2, e2) - i2.start, a3 = 16, o3 = 16;
    n2.length > E.draggingIdx && (a3 = n2[E.draggingIdx]), n2.length >= E.draggingIdx + 1 && (o3 = n2[E.draggingIdx + 1]), r3 < i2.gutterSize + a3 && (r3 = i2.gutterSize + a3), r3 >= i2.size - (i2.gutterSize + o3) && (r3 = i2.size - (i2.gutterSize + o3)), V(t2, r3);
  }, [E.isDragging, E.draggingIdx, E.pairs, V]);
  const W = () => {
    if (E.isDragging) {
      if (void 0 === E.draggingIdx)
        throw new Error("Cannot calculate sizes after dragging = 'state.draggingIdx' is undefined");
      F(r2, E.draggingIdx), T();
    }
  }, M = (e2) => {
    E.isDragging && (b(e2) && e2.preventDefault(), A(e2, r2, r2 === z.Horizontal ? a2 : o2));
  };
  function X(e2, t2) {
    if (!e2.current)
      throw new Error("Can't add element to ref object - ref isn't initialized");
    t2 && !e2.current.includes(t2) && e2.current.push(t2);
  }
  return l("mouseup", W, [E.isDragging, T]), l("mousemove", M, [r2, E.isDragging, A, a2, o2]), l("touchend", W, [E.isDragging, T], { condition: C }), l("touchmove", M, [r2, E.isDragging, A, a2, o2], { condition: C, passive: !C }), (0, import_react.useEffect)(function() {
    if (!j.current)
      return;
    const e2 = j.current.parentElement;
    if (!e2)
      return;
    const t2 = new ResizeObserver(() => {
      const t3 = getComputedStyle(e2), n2 = r2 === z.Horizontal ? e2.clientWidth : e2.clientHeight;
      P(!!t3 && !!n2);
    });
    return t2.observe(e2), () => {
      t2.disconnect();
    };
  }, [j.current, r2]), (0, import_react.useEffect)(function() {
    if (E.isReady && (!O.current || O.current[0].offsetParent)) {
      if (!O.current || !N.current)
        throw new Error("Cannot create pairs - either variable 'childRefs' or 'gutterRefs' is undefined");
      I.length <= 1 ? L(r2, O.current, N.current, s2) : (L(r2, O.current, N.current, s2), G(r2, O.current, N.current));
    }
  }, [v, E.isReady, r2, L, G, s2]), (0, import_jsx_runtime.jsx)("div", Object.assign({ className: `__dbk__container ${r2}`, ref: j }, { children: E.isReady && I.map((i2, a3) => (0, import_jsx_runtime.jsxs)(import_react.default.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", Object.assign({ ref: (e2) => X(O, e2), className: "__dbk__child-wrapper " + (a3 < D.length ? D[a3] : "") }, { children: i2 }), void 0), a3 < I.length - 1 && (0, import_jsx_runtime.jsx)(u, { ref: (e2) => X(N, e2), className: x, theme: m2, draggerClassName: k, direction: r2, onDragging: () => {
    return F(r2, e2 = a3), void $(r2, e2);
    var e2;
  } }, void 0)] }, a3)) }), void 0);
}
export {
  w as GutterTheme,
  z as SplitDirection,
  m as default,
  C as isTouchDevice
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@devbookhq/splitter/lib/mjs/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@devbookhq_splitter.js.map
